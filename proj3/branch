#!/usr/bin/env python



# NOTE
'''
I'm using this section for notes
Here's and idea:
    I need some system to some driver code to read incoming messages on channels
    and then dispatch them to the appropriate handler code

When first connecting to other branches, do the following in order:
        - listen for connections with branch ids smaller than yours
        - only open connections with branch ids greater than yours
'''
#TODO write the algo to setup connection between branches

###Imports
import sys
sys.path.append('/home/phao3/protobuf/protobuf-3.4.0/python')
import bank_pb2 as bank
import threading
from transport import send__message, read_message
import socket
import pdb # for debugging, use pdb.set_trace()
from select import select # for multiplexing


###Definitions
class Account(object):
    """ A wrapper around a mutex and an account balance
        It's thread safe!!!
        Attributes:
            _balance: (int) set to zero
            _lock: (Lock) used to lock around object
    """
    def __init__(self):
        self._balance = 0
        self._lock = threading.Lock()

    def get_balance(self):
        self._lock.acquire()
        balance = self._balance
        self._lock.release()
        return balance
    
    def set_balance(self, new_balance):
        self._lock.acquire()
        self._balance = new_balance
        self._lock.release()

    def lock(self):
        self._lock.acquire()

    def unlock(self):
        self._lock.release()
'''
I want to separate the snapshot parts 
Here is what I envision for this class:
    There should be the following fields:
        _channel_state: fifo queue representing money in transit
        _recording: true of false
        _socket: the underlying socket of the channel
    There should be the following methods:
        mark_empty(): marks the channel as empty and does not record
        start_recording(): starts recording fifo style of everything that comes in
        stop_recording(): turns off recording
        clear(): clears the channel
        add_transfer(money): adds money into the channel, but it only records it if 
            recording is turned on
        get_state(): returns a copy of the channel state

Note: _channel_state is only concerned with incoming transfers
        
'''
class Channel(object):
    """ Doc string
        
    """
    def __init__(self, socket, from_branch):
        self._channel_state = []
        self._recording = False
        self._socket = socket
        self._from_branch = from_branch # this is a string

    def start_recording(self):
        self._recording = True

    def stop_recording(self):
        self._recording = False

    def clear(self):
        self._channel_state = []

    def mark_empty(self):
        # empty channel and no recording
        self.clear()
        self.stop_recording()
   
    def add_transfer(self,money):
        if self._recording:
           self._channel_state.append(money)

    def get_state(self):
        return self._channel_state[:]


        
###Globals

HOST_NAME = "remote.cs.binghamton.edu"
account = None # type: Account object
channels = []  # list of communication channels
port_number = None
branch_name = None
global_socket = None # this is the global socket for a branch


###Functions

def halt(msg):
    print(msg)
    sys.exit(1)


def init_branch():
    print("Waiting for init message")
    try:
        global_socket.bind((HOST_NAME, port_number))
    except socket.error:
        halt("init_branch: can't bind socket")

    #listen
    try:
        global_socket.listen(3)
    except socket.error:
        halt("init_branch: can't listen on socket")

    # get that first init message
    connection, _ = global_socket.accept()
    init_msg = read_message(connection)

    # set the balance
    account.set_balance(init_msg.balance)
    assert(type(init_msg) == bank.InitBranch)
    branches = list(init_msg.all_branches)

    listen_list = [] # the branches that we listen for a connection from
    connect_list = [] # the branches that we actually initiate the connection to


    # remove ourselves from the list and see how many branches are to the left and right
    for i in range(len(branches)):
        if branches[i].name == branch_name:
            listen_list = branches[:i]
            connect_list = branches[i+1:]
            branches.pop(i)
            break
    # now setup connections to all other    

    # listen first
    for branch in listen_list:
        channel = connect_to_branch(branch, 'passive')
        channels.append(channel)

    # then connect
    for branch in connect_list:
        channel = connect_to_branch(branch, 'active')
        channels.append(channel)

    # NOTE: don't forget about the global_socket that is getting messages
    #   from the controller

    print("We did it")




def connect_to_branch(branch, mode):
    """ branch is a bank.Branch object
        mode is a string either 'passive' or 'active'
        returns a new channel object
    """
    assert(type(branch) == bank.InitBranch.Branch)
    ip = branch.ip
    port = branch.port
    name = branch.name
    if mode == 'passive':
        connection, _ = global_socket.accept()
        return Channel(connection, name)


    elif mode == 'active':
        # NOTE connect even if we fail try again
        # never give up, never surrender
        while True:
            try:
                connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                connection.connect((ip,port))
            except socket.error:
                continue
            break
        return Channel(connection, name)
    else:
        raise ValueError("invalid mode :" + mode)
    

def receiver():
    pass

def sender():
    print("Starting sender")

#TODO not really sure if this is how it's going to go
# meaning I'm not sure if I am going to include the functions below





###Main
if __name__ == '__main__':
    #Init values
    account = Account()
    #Handle args
    if len(sys.argv) < 2:
        print("Usage: %s name port_num" %(sys.argv[0]))
        sys.exit(1)

    branch_name = sys.argv[1]
    port_number = int(sys.argv[2])

    global_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    init_branch()

    #sender_thread = threading.Thread(target=sender, args=[])
    #sender_thread.start()

    #receiver()



