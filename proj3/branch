#!/usr/bin/env python



# NOTE
'''
I'm using this section for notes
Here's and idea:
    I need some system to some driver code to read incoming messages on channels
    and then dispatch them to the appropriate handler code

When first connecting to other branches, do the following in order:
        - listen for connections with branch ids smaller than yours
        - only open connections with branch ids greater than yours
'''
#TODO write the algo to setup connection between branches

###Imports
import sys
sys.path.append('/home/phao3/protobuf/protobuf-3.4.0/python')
import bank_pb2 as bank
import threading
from transport import send__message, read_message
import socket
import pdb # for debugging, use pdb.set_trace()
from select import select # for multiplexing
from time import sleep
import random


###Definitions
class Account(object):
    """ A wrapper around a mutex and an account balance
        It's thread safe!!!
        Attributes:
            _balance: (int) set to zero
            _lock: (Lock) used to lock around object
    """
    def __init__(self):
        self._balance = 0
        self._lock = threading.Lock()

    def get_balance(self):
        balance = self._balance
        return balance
    
    def set_balance(self, new_balance):
        self._balance = new_balance

    def lock(self):
        self._lock.acquire()

    def unlock(self):
        self._lock.release()
'''
I want to separate the snapshot parts 
Here is what I envision for this class:
    There should be the following fields:
        _channel_state: just an accumulator for money
        _recording: true of false
        _socket: the underlying socket of the channel
    There should be the following methods:
        mark_empty(): marks the channel as empty and does not record
        start_recording(): starts recording everything that comes in
        stop_recording(): turns off recording
        clear(): clears the channel
        add_transfer(money): adds money into the channel, but it only records it if 
            recording is turned on
        get_state(): returns the channel state

Note: _channel_state is only concerned with incoming transfers
        
'''
class Channel(object):
    """ Doc string
        
    """
    def __init__(self, socket, from_branch):
        self._channel_state = 0 # meaning empty
        self._recording = False
        self._socket = socket
        self._from_branch = from_branch # this is a string

    def start_recording(self):
        self._recording = True

    def stop_recording(self):
        self._recording = False

    def clear(self):
        self._channel_state = 0

    def mark_empty(self):
        # empty channel and no recording
        self.clear()
        self.stop_recording()
   
    def add_transfer(self,money):
        if self._recording:
           self._channel_state += money

    def get_state(self):
        return self._channel_state

    # wrapper method to be used by select
    def fileno(self):
        return self._socket.fileno()


        
###Globals

HOST_NAME = "remote.cs.binghamton.edu"
account = None # type: Account object
channels = []  # list of communication channels
port_number = None
branch_name = None
global_socket = None # this is the global socket for a branch
contoller_socket = None


###Functions

def halt(msg):
    print(msg)
    sys.exit(1)


def init_branch():
    print("Waiting for init message")
    global contoller_socket

    try:
        global_socket.bind((HOST_NAME, port_number))
    except socket.error:
        halt("init_branch: can't bind socket")

    #listen
    try:
        global_socket.listen(3)
    except socket.error:
        halt("init_branch: can't listen on socket")

    # get that first init message
    contoller_socket, _ = global_socket.accept()
    init_msg = read_message(contoller_socket)

    # set the balance
    account.lock()
    account.set_balance(init_msg.balance)
    account.unlock()
    assert(type(init_msg) == bank.InitBranch)
    branches = list(init_msg.all_branches)

    listen_list = [] # the branches that we listen for a connection from
    connect_list = [] # the branches that we actually initiate the connection to


    # remove ourselves from the list and see how many branches are to the left and right
    for i in range(len(branches)):
        if branches[i].name == branch_name:
            listen_list = branches[:i]
            connect_list = branches[i+1:]
            branches.pop(i)
            break
    # now setup connections to all other    

    # listen first
    for branch in listen_list:
        channel = connect_to_branch(branch, 'passive')
        channels.append(channel)

    # then connect
    for branch in connect_list:
        channel = connect_to_branch(branch, 'active')
        channels.append(channel)

    # NOTE: don't forget about the global_socket that is getting messages
    #   from the controller

    print("We did it")
    print(account.get_balance())




def connect_to_branch(branch, mode):
    """ branch is a bank.Branch object
        mode is a string either 'passive' or 'active'
        returns a new channel object
    """
    assert(type(branch) == bank.InitBranch.Branch)
    ip = branch.ip
    port = branch.port
    name = branch.name
    if mode == 'passive':
        connection, _ = global_socket.accept()
        return Channel(connection, name)


    elif mode == 'active':
        # NOTE connect even if we fail try again
        # never give up, never surrender
        while True:
            try:
                connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                connection.connect((ip,port))
            except socket.error:
                continue
            break
        return Channel(connection, name)
    else:
        raise ValueError("invalid mode :" + mode)
    

def receiver():
    assert(type(global_socket) == socket.socket) # <- TODO take this code out

    while True:
        # added a time out so that the other thread cou
        readable = select(channels + [contoller_socket],  [], [],)[0]


        for channel in readable:
            if type(channel) == socket.socket: # this means there is input on the contoller_socket 
                print("There is data on the  contoller_socket?")
                message = read_message(contoller_socket)
                if type(message) == bank.InitSnapshot:
                    print("%s Controller wants snapshot!" %(branch_name))
                    # TODO add logic for starting the snapshot
                
            else:
                message = read_message(channel._socket)
                # check if we got a Transfer message
                if type(message) == bank.Transfer:
                    account.lock()
                    balance = account.get_balance()
                    balance += message.money
                    account.set_balance(balance)
                    account.unlock()
                    print("%s got a %d" %(branch_name, message.money))

    
def sender():
    print("Starting sender")


    while True:
        # select a random channel to send to
        channel = channels[random.randint(0, len(channels) - 1)]

        #lock the account
        account.lock()

        percentage = random.randint(1,5) * 0.01

        balance = account.get_balance()
        withdrawl_ammount = int(balance * percentage)
        account.set_balance(balance - withdrawl_ammount)

        # construct the message to send to our channel of choice
        transfer = bank.Transfer()
        transfer.money = withdrawl_ammount
        branch_msg = bank.BranchMessage()
        branch_msg.transfer.CopyFrom(transfer)


        send__message(channel._socket, branch_msg)
        #print(withdrawl_ammount)
        print("%s sent %s %d" %(branch_name, channel._from_branch, withdrawl_ammount)) 
        account.unlock()

        
        #end of the code
        sleep_time = random.randint(0,5)
        sleep(sleep_time)






###Main
if __name__ == '__main__':
    #Init values
    account = Account()
    #Handle args
    if len(sys.argv) < 2:
        print("Usage: %s name port_num" %(sys.argv[0]))
        sys.exit(1)

    branch_name = sys.argv[1]
    port_number = int(sys.argv[2])

    global_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    init_branch()

    sender_thread = threading.Thread(target=sender, args=[])
    sender_thread.start()

    receiver()



